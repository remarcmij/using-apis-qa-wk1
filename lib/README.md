# Custom Promise Implementation

File: lib/custom-promise.js

<< Explanation generated by GitHub Copilot >>

This code defines a custom implementation of a Promise-like class called `CustomPromise`. It closely mimics the behavior of native JavaScript Promises, providing asynchronous resolution and rejection, as well as chaining via `then` and `catch` methods. The class uses private fields (denoted by `#`) to encapsulate its internal state, such as the current status (`pending`, `fulfilled`, or `rejected`), the resolved value or rejection reason, and arrays to store handlers for fulfillment and rejection.

The static methods `resolve` and `reject` allow for easy creation of already-fulfilled or already-rejected promises, similar to the native `Promise.resolve` and `Promise.reject`. Each instance of `CustomPromise` is assigned a unique ID for debugging and logging purposes, which is incremented with each new promise.

The constructor accepts an executor function, which is immediately invoked with `resolve` and `reject` callbacks. These callbacks update the promise's state and trigger any queued handlers. If the executor throws an error, the promise is automatically rejected with that error.

The `then` method enables chaining by returning a new `CustomPromise`. It schedules the appropriate handler (fulfilled or rejected) to run as a microtask, ensuring asynchronous execution. If the promise is still pending, the handlers are queued for later execution. The `catch` method is a convenience wrapper for handling rejections, simply calling `then` with `null` for the fulfillment handler.

Throughout the implementation, there are detailed console logs (using `chalk` for colored output) to trace the lifecycle of each promise and its microtasks. This is particularly useful for debugging and understanding the flow of asynchronous operations.
